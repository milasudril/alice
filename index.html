<!DOCTYPE html>
<html>
<head>
 <meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="fonts.css">
<link rel="stylesheet" type="text/css" href="doclayout.css">
<link rel="stylesheet" type="text/css" href="doccolors.css">
<link rel="stylesheet" type="text/css" href="dochighlight.css">
<title>Alice Long optIons C++ Extractor</title>
</head>
<body>
<header>
<div class="logo">Alice</div>
</header>
<main>

<h1>Alice</h2>
<p>Alice Long optIons C++ Extractor is a command line parser for use with C++. Alice makes it easy to fetch a command line options, without the need for converting strings to the desired type. Alice also provides automatic help text generation, as well as the ability to export the command line in JSON format.</p>

<h2>Obtaining Alice</h2>
<p>The source for the latest Alice can be obtained by cloning the git repository</p>
<pre><code>git clone https://github.com/milasudril/alice</code></pre>

<p>To compile it, <a href="https://milasudril.github.io/maike">Maike</a> is required, as well as a C++-14 complient compiler. The library can be installed by using the supplied install script:</p>

<pre>maike
./install.sh --prefix=/home/bob
</pre>

<p>or if root</p>

<pre>maike
sudo ./install.sh
</pre>

<p>Since <code>/usr/local</code> is the default prefix, Alice will be installed there.</p>

<h2>Using Alice</h2>
<p>An application that uses Alice needs to link to <code>libalice</code>. Using <a href="https://milasudril.github.io/maike">Maike</a>, the "Hello, World" application looks like</p>

<pre>
//@	{
//@	"targets":
//@		[{
//@		 "name":"hello","type":"application"
//@		,"dependencies":[{"ref":"alice","rel":"external"}]
//@		}]
//@	}

#include &lt;alice/alice.hpp&gt;

ALICE_OPTION_DESCRIPTOR(OptionDescriptor
	,{"Category","option-name","Option description","string",Alice::Option::Multiplicity::ZERO_OR_ONE});

int main(int argc,char** argv)
	{
	try
		{
		Alice::CommandLine&lt;OptionDescriptor&gt; cmdline(argc,argv);

	//	Use the command line object. See test.cpp for more info.

		cmdline.help(1);
		}
	catch(const Alice::ErrorMessage&amp; msg)
		{
		fprintf(stderr,"Command line error: %s\n",msg.data);
		return -1;
		}

	return 0;
	}
</pre>

<p>Since Alice requires C++14, additional options may be needed to the compiler. When using <a href="https://milasudril.github.io/maike">Maike</a>, set the field <em>cxxversion_min</em> in the project configuration file to a value greater than or equal to <strong>201402</strong> to ensure that C++14 features are enabled.</p>

<p>The file <a href="https://github.com/milasudril/alice/blob/master/test.cpp"><code>test.cpp</code></a> contains a minimal example demonstrating Alice's features. Since Maike will store all targets in the <code>__targets</code> directory, it can be run by executing</p>

<pre><code>__targets/test</code></pre>

<p>from the Alice source directory. The command</p>

<pre><code>__targets/test --help</code></pre>

<p>shows a description of the command line.</p>

<h3>Creating a type alias</h3>
<p>Alice uses quite technical names for data types. While this works well for generating the placeholder help text for the test application, it is probably not what an end user expects to see. If a built-in type is used to represent the value of a parameter, but its name is inappropriate, it is possible to define a type alias by inheriting from the corresponding version of <code>MakeType</code>.</p>

<pre>
namespace Alice
	{
	template&lt;&gt;
	struct MakeType&lt;Stringkey("length")&gt;:public MakeType&lt;Stringkey("double")&gt;
		{};
	}
</pre>

<p>Then, it is possible to use <code>length</code> instead of <code>double</code> in the option descriptor. If a <code>length</code> needs another explanation than a <code>double</code>, the description can be overrided:</p>

<pre>
namespace Alice
	{
	template&lt;&gt;
	struct MakeType&lt;Stringkey("length")&gt;:public MakeType&lt;Stringkey("double")&gt;
		{
		static constexpr const char* descriptionGet() noexcept
			{return "The length measured in meters";}
		};
	}
</pre>


<h3>Defining custom types</h3>
<p>Alice can also be extended by defining custom types. For example, there might be an option that accepts <code>Hatter</code> objects.</p>

<pre>
struct Hatter
	{
	std::string name;
	double madness;
	};
</pre>


<p>To add the <code>Hatter</code> type, first specialize the <code>MakeType</code> struct as above:</p>

<pre>
namespace Alice
	{
	template&lt;&gt;
	struct MakeType&lt;Stringkey("hatter")&gt;
		{
		typedef Hatter Type;
		static constexpr const char* descriptionGet() noexcept
			{
			return "A Hatter is entered as a pair `name,madness` where "
				"name is a string, and madness is a value greater than or equal to zero.";
			}
		};
	}
</pre>

<p>If the print method is ever called on the command line object, add a specialization of `Alice::print`</p>

<pre>
namespace Alice
	{
	template&lt;&gt;
	void print&lt;Hatter&gt;(const Hatter&amp; hatter,FILE* dest)
		{
		fprintf(dest,"{\"name\":");
		print(hatter.name,dest);
		fprintf(dest,",\"madness\":");
		print(hatter.madness,dest);
		fprintf(dest,"}\n");
		}
	}
</pre>

<p>Finally, implement a parser, that converts a <code>std::string</code> to a <code>Hatter</code>, this takes more effort 
(see <a href="https://github.com/milasudril/alice/blob/master/test.cpp"><code>test.cpp</code></a>), but below is a stub, that can be used as a starting point:</p>

<pre>
namespace Alice
	{
	template&lt;class ErrorHandler&gt;
	struct MakeValue&lt;Hatter,ErrorHandler&gt;
		{
		static Hatter make_value(const std::string&amp; str);
		};

	template&lt;class ErrorHandler&gt;
	Hatter MakeValue&lt;Hatter,ErrorHandler&gt;::make_value(const std::string&amp; str)
		{
		Hatter ret;
	//	Convert `str` into a Hatter somehow...
	
		return std::move(ret);
		}
	}
</pre>

</main>
<footer><address>Torbj√∂rn Rathsman 2016</address></footer>


</body>
</html>